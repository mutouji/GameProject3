// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Game_Define.proto

#ifndef PROTOBUF_Game_5fDefine_2eproto__INCLUDED
#define PROTOBUF_Game_5fDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Game_5fDefine_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
inline void InitDefaults() {
}
}  // namespace protobuf_Game_5fDefine_2eproto

enum EObjectType {
  OT_NONE = 0,
  OT_PLAYER = 1,
  OT_ROBOT = 2,
  OT_MONSTER = 3,
  OT_PET = 4,
  OT_PARTNER = 5,
  OT_SUMMON = 6,
  EObjectType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EObjectType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EObjectType_IsValid(int value);
const EObjectType EObjectType_MIN = OT_NONE;
const EObjectType EObjectType_MAX = OT_SUMMON;
const int EObjectType_ARRAYSIZE = EObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EObjectType_descriptor();
inline const ::std::string& EObjectType_Name(EObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EObjectType_descriptor(), value);
}
inline bool EObjectType_Parse(
    const ::std::string& name, EObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EObjectType>(
    EObjectType_descriptor(), name, value);
}
enum EActionType {
  AT_NONE = 0,
  AT_IDLE = 1,
  AT_WALK = 2,
  AT_RUN = 3,
  AT_FLY = 4,
  AT_DANCE1 = 5,
  AT_DANCE2 = 6,
  AT_DANCE3 = 7,
  AT_DANCE4 = 8,
  EActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EActionType_IsValid(int value);
const EActionType EActionType_MIN = AT_NONE;
const EActionType EActionType_MAX = AT_DANCE4;
const int EActionType_ARRAYSIZE = EActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EActionType_descriptor();
inline const ::std::string& EActionType_Name(EActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EActionType_descriptor(), value);
}
inline bool EActionType_Parse(
    const ::std::string& name, EActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EActionType>(
    EActionType_descriptor(), name, value);
}
enum EActionStatue {
  AS_NONE = 0,
  AS_HURT = 1,
  AS_START = 2,
  AS_END = 268435455,
  EActionStatue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EActionStatue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EActionStatue_IsValid(int value);
const EActionStatue EActionStatue_MIN = AS_NONE;
const EActionStatue EActionStatue_MAX = AS_END;
const int EActionStatue_ARRAYSIZE = EActionStatue_MAX + 1;

const ::google::protobuf::EnumDescriptor* EActionStatue_descriptor();
inline const ::std::string& EActionStatue_Name(EActionStatue value) {
  return ::google::protobuf::internal::NameOfEnum(
    EActionStatue_descriptor(), value);
}
inline bool EActionStatue_Parse(
    const ::std::string& name, EActionStatue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EActionStatue>(
    EActionStatue_descriptor(), name, value);
}
enum ECampType {
  CT_NONE = 0,
  CT_PVE_PLAYER = 1,
  CT_PVE_ENEMY = 2,
  CT_PVE_NEUTRAL = 3,
  CT_PVP_PLAYER1 = 4,
  CT_PVP_PLAYER2 = 5,
  CT_PVP_PLAYER3 = 6,
  CT_PVP_PLAYER4 = 7,
  CT_PVP_PLAYER5 = 8,
  CT_CMAP_END = 100,
  ECampType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ECampType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ECampType_IsValid(int value);
const ECampType ECampType_MIN = CT_NONE;
const ECampType ECampType_MAX = CT_CMAP_END;
const int ECampType_ARRAYSIZE = ECampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECampType_descriptor();
inline const ::std::string& ECampType_Name(ECampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECampType_descriptor(), value);
}
inline bool ECampType_Parse(
    const ::std::string& name, ECampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECampType>(
    ECampType_descriptor(), name, value);
}
enum ECopyType {
  CPT_NONE = 0,
  CPT_LOGIN = 1,
  CPT_SELROLE = 2,
  CPT_CITY = 3,
  CPT_MAIN = 4,
  CPT_WORLD = 5,
  CPT_END = 100,
  ECopyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ECopyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ECopyType_IsValid(int value);
const ECopyType ECopyType_MIN = CPT_NONE;
const ECopyType ECopyType_MAX = CPT_END;
const int ECopyType_ARRAYSIZE = ECopyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECopyType_descriptor();
inline const ::std::string& ECopyType_Name(ECopyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECopyType_descriptor(), value);
}
inline bool ECopyType_Parse(
    const ::std::string& name, ECopyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECopyType>(
    ECopyType_descriptor(), name, value);
}
enum EObjectStatus {
  EOS_NONE = 0,
  EOS_DEAD = 1,
  EOS_IDLE = 2,
  EOS_WALK = 3,
  EOS_RUN = 4,
  EOS_FLY = 5,
  EOS_NOT_MOVE = 6,
  EOS_NOT_CAST = 7,
  EOS_NOT_BEHURT = 8,
  EOS_NOT_BECONTROL = 9,
  EOS_STEALTH = 10,
  EOS_BLIND = 11,
  EObjectStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EObjectStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EObjectStatus_IsValid(int value);
const EObjectStatus EObjectStatus_MIN = EOS_NONE;
const EObjectStatus EObjectStatus_MAX = EOS_BLIND;
const int EObjectStatus_ARRAYSIZE = EObjectStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* EObjectStatus_descriptor();
inline const ::std::string& EObjectStatus_Name(EObjectStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EObjectStatus_descriptor(), value);
}
inline bool EObjectStatus_Parse(
    const ::std::string& name, EObjectStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EObjectStatus>(
    EObjectStatus_descriptor(), name, value);
}
enum EItemType {
  EIT_NONE = 0,
  EIT_EQUIP = 1,
  EIT_ACTIONDRUG = 2,
  EIT_MAT = 3,
  EIT_BOX = 4,
  EIT_KEY = 5,
  EIT_CHIP = 6,
  EIT_GEM = 7,
  EIT_FASHION = 8,
  EIT_MONEY = 9,
  EIT_ACTION = 10,
  EIT_EXP = 11,
  EIT_RUNE = 12,
  EIT_PETSOUL = 13,
  EIT_TASK = 14,
  EIT_DRUG = 15,
  EIT_PET = 16,
  EIT_PARTNER = 17,
  EItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EItemType_IsValid(int value);
const EItemType EItemType_MIN = EIT_NONE;
const EItemType EItemType_MAX = EIT_PARTNER;
const int EItemType_ARRAYSIZE = EItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EItemType_descriptor();
inline const ::std::string& EItemType_Name(EItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EItemType_descriptor(), value);
}
inline bool EItemType_Parse(
    const ::std::string& name, EItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EBagType {
  EBT_NONE = 0,
  EBT_ITEM = 1,
  EBT_GEM = 2,
  EBT_FASHION = 3,
  EBT_CHIP = 4,
  EBT_RUNE = 5,
  EBT_TASK = 6,
  EBT_SOUL = 7,
  EBT_CARD = 8,
  EBagType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EBagType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EBagType_IsValid(int value);
const EBagType EBagType_MIN = EBT_NONE;
const EBagType EBagType_MAX = EBT_CARD;
const int EBagType_ARRAYSIZE = EBagType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBagType_descriptor();
inline const ::std::string& EBagType_Name(EBagType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBagType_descriptor(), value);
}
inline bool EBagType_Parse(
    const ::std::string& name, EBagType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBagType>(
    EBagType_descriptor(), name, value);
}
enum EFunctionType {
  FUNC_BEGIN_ID = 0,
  FUNC_END_ID = 150,
  EFunctionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EFunctionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EFunctionType_IsValid(int value);
const EFunctionType EFunctionType_MIN = FUNC_BEGIN_ID;
const EFunctionType EFunctionType_MAX = FUNC_END_ID;
const int EFunctionType_ARRAYSIZE = EFunctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EFunctionType_descriptor();
inline const ::std::string& EFunctionType_Name(EFunctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EFunctionType_descriptor(), value);
}
inline bool EFunctionType_Parse(
    const ::std::string& name, EFunctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EFunctionType>(
    EFunctionType_descriptor(), name, value);
}
enum EAttrID {
  NONE = 0,
  HP = 1,
  MP = 2,
  HP_MAX = 3,
  MP_MAX = 4,
  HP_REC = 5,
  MP_REC = 6,
  SPEED = 7,
  ATTACK = 8,
  ELEMENT = 9,
  MAGIC_DEF = 10,
  PHYSIC_DEF = 11,
  HIT = 12,
  DODGE = 13,
  MORE_HURT = 14,
  LESS_HURT = 15,
  CRIT_HIT = 16,
  CRIT_DEF = 17,
  ICE_DODGE = 18,
  FLASH_DODGE = 19,
  FIRE_DODGE = 20,
  TOXIN_DODGE = 21,
  EAttrID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EAttrID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EAttrID_IsValid(int value);
const EAttrID EAttrID_MIN = NONE;
const EAttrID EAttrID_MAX = TOXIN_DODGE;
const int EAttrID_ARRAYSIZE = EAttrID_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAttrID_descriptor();
inline const ::std::string& EAttrID_Name(EAttrID value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAttrID_descriptor(), value);
}
inline bool EAttrID_Parse(
    const ::std::string& name, EAttrID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAttrID>(
    EAttrID_descriptor(), name, value);
}
enum EBuffType {
  BFT_NONE = 0,
  EBuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EBuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EBuffType_IsValid(int value);
const EBuffType EBuffType_MIN = BFT_NONE;
const EBuffType EBuffType_MAX = BFT_NONE;
const int EBuffType_ARRAYSIZE = EBuffType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EBuffType_descriptor();
inline const ::std::string& EBuffType_Name(EBuffType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EBuffType_descriptor(), value);
}
inline bool EBuffType_Parse(
    const ::std::string& name, EBuffType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EBuffType>(
    EBuffType_descriptor(), name, value);
}
enum EChatChannel {
  CHL_NONE = 0,
  CHL_WORLD = 1,
  CHL_PRIVATE = 2,
  CHL_GUILD = 3,
  CHL_GM = 4,
  EChatChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EChatChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EChatChannel_IsValid(int value);
const EChatChannel EChatChannel_MIN = CHL_NONE;
const EChatChannel EChatChannel_MAX = CHL_GM;
const int EChatChannel_ARRAYSIZE = EChatChannel_MAX + 1;

const ::google::protobuf::EnumDescriptor* EChatChannel_descriptor();
inline const ::std::string& EChatChannel_Name(EChatChannel value) {
  return ::google::protobuf::internal::NameOfEnum(
    EChatChannel_descriptor(), value);
}
inline bool EChatChannel_Parse(
    const ::std::string& name, EChatChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EChatChannel>(
    EChatChannel_descriptor(), name, value);
}
enum EEquipPos {
  EEP_NONE = 0,
  EEP_HELMET = 1,
  EEP_NECKLACE = 2,
  EEP_ARMOR = 3,
  EEP_SHOES = 4,
  EEP_WRIST = 5,
  EEP_RING = 6,
  EEP_TALISMAN = 7,
  EEP_WEAPON = 8,
  EEquipPos_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EEquipPos_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EEquipPos_IsValid(int value);
const EEquipPos EEquipPos_MIN = EEP_NONE;
const EEquipPos EEquipPos_MAX = EEP_WEAPON;
const int EEquipPos_ARRAYSIZE = EEquipPos_MAX + 1;

const ::google::protobuf::EnumDescriptor* EEquipPos_descriptor();
inline const ::std::string& EEquipPos_Name(EEquipPos value) {
  return ::google::protobuf::internal::NameOfEnum(
    EEquipPos_descriptor(), value);
}
inline bool EEquipPos_Parse(
    const ::std::string& name, EEquipPos* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EEquipPos>(
    EEquipPos_descriptor(), name, value);
}
enum ETaskStatus {
  ETS_INIT = 0,
  ETS_ACCEPT = 1,
  ETS_FINISH = 2,
  ETS_COMMIT = 3,
  ETaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ETaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ETaskStatus_IsValid(int value);
const ETaskStatus ETaskStatus_MIN = ETS_INIT;
const ETaskStatus ETaskStatus_MAX = ETS_COMMIT;
const int ETaskStatus_ARRAYSIZE = ETaskStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ETaskStatus_descriptor();
inline const ::std::string& ETaskStatus_Name(ETaskStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ETaskStatus_descriptor(), value);
}
inline bool ETaskStatus_Parse(
    const ::std::string& name, ETaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ETaskStatus>(
    ETaskStatus_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::EObjectType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EObjectType>() {
  return ::EObjectType_descriptor();
}
template <> struct is_proto_enum< ::EActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EActionType>() {
  return ::EActionType_descriptor();
}
template <> struct is_proto_enum< ::EActionStatue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EActionStatue>() {
  return ::EActionStatue_descriptor();
}
template <> struct is_proto_enum< ::ECampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECampType>() {
  return ::ECampType_descriptor();
}
template <> struct is_proto_enum< ::ECopyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECopyType>() {
  return ::ECopyType_descriptor();
}
template <> struct is_proto_enum< ::EObjectStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EObjectStatus>() {
  return ::EObjectStatus_descriptor();
}
template <> struct is_proto_enum< ::EItemType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EItemType>() {
  return ::EItemType_descriptor();
}
template <> struct is_proto_enum< ::EBagType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBagType>() {
  return ::EBagType_descriptor();
}
template <> struct is_proto_enum< ::EFunctionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EFunctionType>() {
  return ::EFunctionType_descriptor();
}
template <> struct is_proto_enum< ::EAttrID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAttrID>() {
  return ::EAttrID_descriptor();
}
template <> struct is_proto_enum< ::EBuffType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBuffType>() {
  return ::EBuffType_descriptor();
}
template <> struct is_proto_enum< ::EChatChannel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EChatChannel>() {
  return ::EChatChannel_descriptor();
}
template <> struct is_proto_enum< ::EEquipPos> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EEquipPos>() {
  return ::EEquipPos_descriptor();
}
template <> struct is_proto_enum< ::ETaskStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETaskStatus>() {
  return ::ETaskStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Game_5fDefine_2eproto__INCLUDED
